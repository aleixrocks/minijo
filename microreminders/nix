PRINCIPLES
 - There isn't anything like apt which solves a SAT problem in order to satisfy
   dependencies with lower and upper bounds on versions. There's no need for
   this because all the dependencies are static: if a derivation X depends on a
   derivation Y, then it always depends on it. A version of X which depended on
   Z would be a different derivation. 
 - nix derivatives : packages (including version and specific deps)
 - nix channel : repository of nix packages. a channel can be just a directory
   with the git clone of the nixpkgs repo. Essentially it must have a
   default.nix file that evalutes to an attribute set ( {ping=...; bash=...; ...;}
   containing derivatives.
 - nix expressions : descriptions of a package/derivative
 - The Nix language is used to write expressions that produce derivations. The
   nix-build tool is used to build derivations from an expression.
 - The .nix files are like .c files. The .drv files are intermediate files like
   .o files. The .drv describes how to build a derivation, it's the bare
   minimum information. The output of a build is the "output" path.
 - Derivations are also stored in the nix store. But they only contain the
   instructions on how to build a program. Derivations can be created with the
   nix "derivation" function. 
 - The hash of the out path of a package is based solely on the input
   derivations in the current version of Nix, not on the contents of the build
   product (no sha on the resulting binary). It's possible however to have
   content-addressable derivations for e.g. tarballs.
 - The environment variables passed to the builder are just those you see in
   the .drv plus some other Nix related configuration (number of cores, temp
   dir, ...). The builder will not inherit any variable from your running
   shell, otherwise builds would suffer from non-determinism.
 - An attribute set (ej. {a=3; b="patata";}  with type="derivation" is nix's
   magic way to let it now that the set is a derivation. Another set special
   attribute is "outPath". If it exist, the builtins.toString or
   "${derviationVariable} will essentially return the contents of outPath.
 - The idea is that all sources should reside in the Nix store, since all
   inputs to a derivation should reside in the Nix store.
 - During build, every attribute in the derivation is passed as an environment
   variable to the builder. See
   https://nixos.org/manual/nix/stable/expressions/derivations.html for more
   details.
 - if an attribute of "derivation" is a path (/...) it is copied into the nix
   store first. hence, we can keep track of all sources in the store.
 - each derivation can have multiple outputs. Each output has a name (out is
   the generic one) and this corresponds to a path in the nix store. These
   names are exported as env variables to the builder who needs to do what's
   necessary to copy into each output path what's expected (e.g. headers, libs,
   dev libs, doc, etc).
 - derivations have dependencies to other derivations. When inspecting one with
   nix show-derivation <name>.drv, you will see the .drv dependencies and the
   specific outputs of the .drv this derivation depends on.
 - nix components:
    - /nix/store : installation path of all packages
    - /nix/var/nix/db : sqlite database that keep track of packages
    - ~/.nix-profile : this is a nix package that works as a kind
      of a root directory. But nothing is installed here, is only a
      simlink. We can install packages in this "profile". For each
      package installed, a new generation is created (another
      profile) which is installed in the store and this simlink is
      updated to point to the new one. Profiles are here
      /nix/var/nix/profiles/per-user/aleix/ but they are only
      simlinks to the store.
    - ~/.nix-defexpr/channels : this contains the repos with the "expressions"
      of packages.
    - /etc/nix/nix.conf : nix global configurations. See
      https://nixos.org/manual/nix/stable/command-ref/conf-file.html for
      options
    - NIX_PATH : env var containing the path to repositories of nix
      expressions. They contain a default.nix which nix commands evaluate to
      find derivatives. These repositories are paths with names assigned, e.g.
      : nixpkgs=/nix/var/nix/profiles/per-user/aleix/channels/nixpkgs . When
      referring to this repos inside nix expressions (.nix files) you can do so
      as <nixpkgs>. Be aware that nix-env does not uses NIX_PATH but
      ~/.nix-defexpr as source for its repositories. If you want to use a repo
      from NIX_PATH in nix-env, use nix-env -f '<myRepo>' -A <attrName> . You
      can also use -I <path> in some nix tools to add a path instead of
      NIX_PATH. For more info, see
      https://nixos.org/guides/nix-pills/nix-search-paths.html
    - nix-env : command to manage the environment (profiles and
      packages installed there)
    - nix-instantiate <name>.nix : command that takes a .nix file and build a
      .drv file.
    - nix-store: command to manage the store itself and build. nix-store -r
      takes a .drv file and build the package itself.
    - nix-build: command that takes a .nix file, builds a .drv file and runs
      nix-store -r on the .drv to build the package. If no file is provided, it
      will read a "default.nix" in the current directory. If this file contains
      an attribute set, you can specify which attribute you want it to read
      with -A, e.g. nix-build -A graphviz. Instead of default.nix, you can also
      specify a NIX_PATH such as nix-build '<nixpkgs' -A bash.
    - nix-channel: command to manage channels (repos)
    - nix-repl: command to try the NIX language interactively
    - source ~/.nix-profile/etc/profile.d/nix.sh : load all nix commands and
      envs (used when nix is not installed using the system's packet manager)
    - nix-shell file.nix :  builds a derivation and opens an interactive bash
      with the build environment loaded, but no build is done. From here, it is
      possible to run the builder to build the package, but you might not have
      permissions to write into the store nor you will be cd into a nix
      temporal build dir.

BASIC
 - nix-env -i <pkg> : install package into the current user environment
 - nix-env --uninstall <pkdg> : remove package from the user environment
 - nix-env -u : upgrade all packages in the environment
 - nix-env -u <pkg> : only upgrade <pkg>
 - nix search <pkg> : search for a package to install
 - nix-env -qa : show available pacakges for installation
 - nix-env -qas : show installed packages: I (installed in current user env) P
   (installed in the system) S (thre is a pre-compiled binary avaialble for
   download)
 - nix-env -qs --installed : show only packages in the current profile
 - nix-env -qa --description neovim : show version of package. Rememeber
   using -f <path> if specifiying a local nix repository.
 - nix-shell <name.nix> : enter a nix user environemnt defined in name.nix
 - nix-shell --pure <name.nix> : enter a nix user environemnt, only that is
   defined in name.nix is available.
 - nix log <path to store> : show build log

GENERATIONS
 - nix-env --list-generations : show history of environemnts
 - nix-env --rollback : go back to previous environemnt state
 - nix-env -G <environment_name> : go the specified environment as lised by --list-generations
 - ~/.nix-profiles/ : current environment
 - ~/.nix-profiles/bin : current binaries (these are a simlink to the nix store)

STORE
 - /nix/store : nix store where all binaries really are
 - nix-store -q --references `which command` : shows dependencies of package.
   Be sure that the path is either an absolute path or a symlink to a command
   in the nix store.
 - nix-store -q --referrers `which command` : shows which packages depend on this package.
 - nix-store -qR <path> : list all dependencies including absolutely everything
   needed to run this. This is named "closure" in nix terminology.
 - nix-store -q -tree <path> : show dependencies as a tree

CHANNELS
 - nix-channel --list : list channels (repositories)
 - nix-channel --update : update list of expressions/(descriptions of packages)

DERIVATIONS
 - nix show-derivation <path.drv> : pretty print derivation
 - nix-store -r <path.drv> : build/realise derivation

GARBAGE COLLECTOR
 - /nix/var/nix/gcroots : contains simlinks to garbage collector roots
   (gcroots). These packages nor their dependencies will never be deleted.
   everythingelse will if the gargabe collector is run. all links under
   /nix/var/nix/profiles are also gcroots, so our env and generations are not
   deleted. the "results" link after a build is also a gc root (the softlink
   file itself, not the .drv it points to!)
 - nix-collect-garbage : command to run the garbage collector
 - nix-store -q --roots `which fortune` : points to the gcroot derivation that
   keeps the fortune package alive after runninc the garbage collector
 - nix-store --gc --print-roots : prints all gc roots
 - clean up all
    - steps: 
       nix-channel --update
       nix-env -u --always
       rm /nix/var/nix/gcroots/auto/*
       nix-collect-garbage -d
    - First, we download a new version of the nixpkgs channel, which holds the
      description of all the software. Then we upgrade our installed packages
      with nix-env -u. That will bring us into a fresh new generation with all
      updated software.
    - Then we remove all the indirect roots generated by nix-build: beware,
      this will result in dangling symlinks. You may be smarter and also remove
      the target of those symlinks.
    - Finally, the -d option of nix-collect-garbage is used to delete old
      generations of all profiles, then collect garbage. After this, you lose
      the ability to rollback to any previous generation. So make sure the new
      generation is working well before running the command.
    - more info at: https://nixos.org/guides/nix-pills/garbage-collector.html

GET THE SOURCE OF A PACKAGE
 - nix-shell -A hello : opens a shell with stdenv and build dependencies
   loaded.
 - eval ${unpackPhase:-unpackPhase} : get and unpack source code in the current
   directory. Now you can examine it!

GET URL AND SHA OF A GITHUB PACKAGE
 - you can get the github tar.gz of a commit as:
     https://github.com/PROJECT/REPO/archive/COMMITID.tar.gz
   e.g.
     https://github.com/nixos/nixpkgs/archive/481f9b246d200205d8bafab48f3bd1aeb62d775b.tar.gz
 - you can easily calculate the sha256 as:
     nix-prefetch-url --unpack  <url>


WHERE IS DEFINED THE NIX SOURCE OF A FUNCTION?
 - type in nix repl:
     nix-repl> glibc.overrideAttrs
     «lambda @ /nix/store/86242z3mxd6lqxyrhdl6vv78rzww6k3z-nixpkgs/nixpkgs/lib/customisation.nix:85:73»

UNDERSTANDING NIXPKGS REPOSITORY
 - The <nixpkgs> repository is a function that accepts some parameters and
   returns the set of all packages. Due to laziness, only the accessed
   derivations will be built.
 - the default.nix evalutes to a function instead of an attribute set. If
   nix-build finds a function instead of an attribute set, it will call the
   function once and evaluate the resulting derivation. This works if the
   function has default parameters of if parameters are passed with --arg
   option. (actually, note that nix-build expectes a derivation, not an
   attribute set, that's why we specify allways the derivation inside the set
   using -A).
 - One of the parameters is system. we can use it for cross compilation. e.g.
   nix-build -A psmisc --argstr system i686-linux (but I'm not much confident
   on this)
 - nixpkgs default.nix reads the nixpkgs config file at
   ~/.config/nixpkgs/config.nix . This con be accesses inside nix repl as "pkgs
   = import <nixpkgs> {}; pkgs.config". The location can also be specified at
   import time as import <nixpkgs> {config = import ./config.nix}
 - If we want to modify a nixpkgs package and also want all packages that
   depend on the modified one to recompile, we need to override it. To do so,
   we can add the following in the config file:
    {
      packageOverrides = pkgs: {
        graphviz = pkgs.graphviz.override { xorg = null; };
      };
    }
   this uses fixed point as explained below. However, it is more powerful to
   use overlays. packageOverrides acts as an overlay with only the super
   argument. It is therefore appropriate for basic use, but overlays are more
   powerful and easier to distribute.

 - What if we want to override a package internal attributes rather than the
   arguments that it accepts before calling mkDerivation? we can use the helper
   <package>.overrideAttrs. The oldAttrs argument refers to the unmodified
   attributes:

     glibc = super.glibc.overrideAttrs (oldAttrs: rec {
        version = "2.27";
        name = "glibc-${version}";
        src = builtins.fetchurl {
            url    = "https://ftp.gnu.org/gnu/glibc/glibc-${version}.tar.xz";
            sha256 = "0wpwq7gsm7sd6ysidv0z575ckqdg13cr2njyfgrbgh4f65adwwji";
        };
     });

 - Overlays are used to add or modify a nixpkgs package and all related
   packages in cascade (fix point below). Here is all info on overlays:
   https://nixos.org/manual/nixpkgs/stable/#chap-overlays
     import <nixpkgs> { overlays = [ overlay1 overlay2 ]; }.
     
     overlay1 = self: super:
     {
       boost = super.boost.override {
         python = self.python3;
       };
       rr = super.callPackage ./pkgs/rr {
         stdenv = self.stdenv_32bit;
       };
     }

   The first argument (self) corresponds to the final package set. You should use
   this set for the dependencies of all packages specified in your overlay. For
   example, all the dependencies of rr in the example above come from self, as
   well as the overridden dependencies used in the boost override.

   The second argument (super) corresponds to the result of the evaluation of
   the previous stages of Nixpkgs. It does not contain any of the packages added
   by the current overlay, nor any of the following overlays. This set should be
   used either to refer to packages you wish to override, or to access functions
   defined in Nixpkgs. For example, the original recipe of boost in the above
   example, comes from super, as well as the callPackage function.

 - stdenv is a "package" used to build other packages in nixpkgs. stdenv
   contains only a "setup" bash script that defines functions to automatically
   build with autotools. You can see it with cd $(nix-build '<nixpkgs>' -A
   stdenv). This is sourced by the nixpkgs builder and calls genericBuild
   function in setup to build everything. The stdenv derivative also contains
   the mkDerivative function, which is used by to create derivatives of all
   nixpkgs packages. Note that mkDerivative is only in the stdenv derivative
   attribute set, but not in the "binary" (nix store). stdenv derivative is
   defined in pkgs/stdenv/generic/default.nix . To build the derivation it uses
   the "derivation" builtint directly instead of mkDerivation, of course. It
   provides its out builder.sh to build itself. It just copies setup.sh and a
   few more lines in the output directory. Note how "mkDerivation" is defined
   as an attribute inside the stdenv derivative attribute set, and note that
   the stdenv itself is passed to mkDerivation. 

   To build a package with nixpackge, use mkDerivation

   Low level stdenv: https://nixos.org/guides/nix-pills/fundamentals-of-stdenv.html
   All stdenv info can be found in https://nixos.org/manual/nixpkgs/stable/#chap-stdenv

 - mkDerivation essentially calls the "derivation" builtin to create a nix
   derivation attribute set, but first it provides a standard build environment
   through stdenv including gcc, tar, gzip, ... and the stdenv setup build
   script to actually build something made with autotools. To see the
   mkDerivation builder.sh, run "nix-build '<nixpkgs>' -A stdenv; cat
   result/setup" here you can see the code for all variables, hooks and phases.
   The mkDerivation doc can also be found under
   https://nixos.org/manual/nixpkgs/stable/#chap-stdenv

     stdenv.mkDerivation rec {
       pname = "libfoo"; # The final drv name is "pname-version".
       version = "1.2.3";
       src = fetchurl {
         url = "http://example.org/libfoo-source-${version}.tar.bz2";
         sha256 = "0x2g1jqygyr5wiwg4ma1nd7w4ydpy82z9gkcv8vh2v8dn3y58v5m";
       };
     }
     
    - buildInputs = [ which hello ]; : direct dependencies of the package
    - propagatedBuildInputs = [ which hello ]; : like buildInputs, but these
      packages are written into $out/nix-support/propagated-build-inputs for
      the current package. Then, if another package imports this package, it
      will source all what's in $out/nix-support/propagated-build-inputs . This
      allows for a package "A" using propagateBuildInputs to make a set of
      packages "Aset" available to a package "B" having "A" as its buildInputs
      to accesses "Aset" without importing them explicitly in its buildInputs.
      see for more info: https://nixos.org/guides/nix-pills/basic-dependencies-and-hooks.html
    - buildPhase = substitute the generic builder build phase for the contents
      of this variable. Example:
        buildPhase = ''
          gcc foo.c -o foo
        '';
    - installPhase = subsitute the generic builder install phase for the
      contents of this variable. Example:
        installPhase = ''
          mkdir -p $out/bin
          cp foo $out/bin
        '';
    - we can skip phases by adding dontInstall=true; dontBuild=true;
      dontConfigure=true; etc. Look at stdenv setup for the available options, it's
      easy to spot.
    - NIX_CFLAGS_COMPILE : this env var adds options to the underlying
      compiler. This works because stdenv provies a cc wrapper that parses this
      env var among doing other things.
    - setuphook: If a package has a setupHook=./setup-hook.sh attribute, all
      packages that include this package will run the setup-hook.sh script.
      This allows to run arbitrary code in any package. This works by storing
      the hook under the package pkg/nix-support/setup-hook.  this will be
      sourced by any stdenv-based build including that as a dependency. 
      more info: https://nixos.org/manual/nixpkgs/stable/#ssec-setup-hooks
      The following example, forces all packages inlcluding 'middle-man' to be
      compiled with frame pointers.

        --- middle-man.nix ---
        {stdenv}:
        stdenv.mkDerivation {
          name = "middle-man";
          src = ./middle-man.sh;
          setupHook = ./setup-hook.sh;

          dontUnpack=true;
          dontPatch=true;
          dontConfigure=true;
          dontBuild=true;
          #dontFixup=true; #this loads setupHook!
                                                                                                                                            
          installPhase = ''
            mkdir -p $out/bin
            cp $src $out/bin
          '';
        }

        --- ./setup-hook.sh ----
        echo "@@@@@@@@@@@@@@@@@I'm the setup hook!@@@@@@@@@@@@@@@@@"                                                                        
        export NIX_CFLAGS_COMPILE="-fno-omit-frame-pointer "$NIX_CFLAGS_COMPILE 
        
        --- hello.nix ---
        {stdenv, middle-man}
        stdenv.mkDerivation {
           name = hello;
           src = ...
           buildInputs = [middle-man];
        }     
        
    - envHooks: similar to setuphook. see fore more
      https://nixos.org/guides/nix-pills/basic-dependencies-and-hooks.html

 - How to recompile the whole system with some compilation option. Create a new
   stdenv with a modified mkDerivation that appends the extra compilation
   option to NIX_CFLAGS_COMPILE. To create a new stdenv, we use an "adapter"
   (<nixpkgs>/pkgs/stdenv/adapters.nix), a helper function that modifies stdenv
   for us. To add cflags, we have withCFlags function:

     let
       nixpkgs = import <nixpkgs> {overlays=[overlay1];};
       overlay1 = self: super: # self is the new, super is the old
       {
         stdenv = super.withCFlags [ "-fno-omit-frame-pointer" ] super.stdenv;                                                       
       };
     in nixpkgs

   Storing this as default.nix and running in the same directory nix-build -A
   hello, will trigger building all hello dependencies (including glibc) with
   the new options.
 
 - Override the glibc. This causes a whole system build. Be aware that the
   glibc is built with a boostrap stdenv which has an older compiler than the
   current "gcc" in nixpkgs.

     glibc = super.glibc.overrideAttrs (oldAttrs: rec {
        version = "2.27";
        name = "glibc-${version}";
        src = builtins.fetchurl {
            url    = "https://ftp.gnu.org/gnu/glibc/glibc-${version}.tar.xz";
            sha256 = "0wpwq7gsm7sd6ysidv0z575ckqdg13cr2njyfgrbgh4f65adwwji";
        };
     });

 - update boostrap tools. The boostrapTools or boostrapFiles are a set of
   pre-built binaries uses to boostrap a system. They are downloaded from the
   nixpkgs servers and used to build stdenv in 5 steps. A good introduction can
   be found here:
     http://trofi.github.io/posts/240-nixpkgs-bootstrap-intro.html
   We can change the boostrap tools, but we first need to generate a new one. To do so, run:
     nix build -f ./pkgs/stdenv/linux/make-bootstrap-tools.nix bootstrapFiles
   this will take the current nixpkgs gcc and pack it into boostrap.  then,
   modify nixpkgs and add the path to the generated boostrap tools. I have
   found no way to override this, so I needed to hardcore it. 
     pkgs/stdenv/linux/bootstrap-files/x86_64.nix
   to use your modified nixpkgs instead of the default one, modify the
   "nixpkgs" path inside NIX_PATH.

 - How nixpkgs is boostraped. First check this:
     http://trofi.github.io/posts/240-nixpkgs-bootstrap-intro.html
   It first loads default.nix in nixpkgs. This leads to 
     ./default.nix
     ./pkgs/top-level/impure.nix
     ./pkgs/top-level/default.nix
   The last one, build a list "stages" containg functions that describe how to
   build the 5 stdenv stages. The "boot" is a function that builds the stdenv
   functions by piping them one after the other (I think)
     129   pkgs = boot stages;
   The stdenv stages are here:
     ./pkgs/stdenv/default.nix # this selects the stdenv for linux
     ./pkgs/stdenv/linux/default.nix # this acutally contains the 5 stages
   To build the stages, it uses a prebuilt set of binaries named boostrapTools.
   This is fetched from nix server instead of being built. However, nixpkgs
   also contains the .nix describing how to build it. This is found under:
     ./pkgs/stdenv/linux/make-bootstrap-tools.nix




FUNDAMENTAL NIXPKGS

 - callPackage: nix trick to transparently find the arguments of a function.
   Given a function, it gets its argument names and intersects them with
   derivations found in allPkgs (nixpkgs).
     callPackage = path: overrides:
     let f = if builtins.isPath path then import path else path;
     in f ((builtins.intersectAttrs (builtins.functionArgs f) allPkgs) // overrides);
   see for more details: https://nixos.org/guides/nix-pills/callpackage-design-pattern.html

 - makeOverridable: nix trick to embedd a function into a derivation. This
   function allows to recreate the derivation with a new set of arguments. the
   new set overrides the original one, but keeps all fields that have not been
   explicitly set by the override method. Here is how it works:
     makeOverridable = f: args:
       let origRes = f args;
       in origRes // {myOverride = newArgs: makeOverridable f (args // newArgs); };
   see for more details: https://nixos.org/guides/nix-pills/override-design-pattern.html
 - Fixed point with lazy evaluation: we use this technique to modify a package
   in nixpkgs and all its dependencies.
     fix = f: let result = f result; in result
     pkgs = self: { a = 3; b = 4; c = self.a+self.b; } #assume that this is nixpkgs, where a, b and c are derivations, but c depends on a and b.
     fix pkgs
   Now we expand this step by step: 
     fix = pkgs*: let result = pkgs* result; in result
     fix = pkgs*: let result = pkgs* result; in pkgs* result
     fix = pkgs*: let result = pkgs* result; in pkgs* (pkgs* result)  # instead of evaluating the innermost pkgs, we evaluate first the outermost pkgs!
     fix = pkgs*: let result = pkgs* result; in self: { a = 3; b = 4; c = self.a+self.b; } #self is the paramter to the outermost pkgs call.
     fix = pkgs*: let result = pkgs* result; in (pkgs* result): { a = 3; b = 4; c = (pkgs* result).a + (pkgs* result).b; }
     fix = pkgs*: let result = pkgs* result; in (pkgs* result): { a = 3; b = 4; c = ({ a = 3; b = 4; c = self.a+self.b; }).a + ({ a = 3; b = 4; c = self.a+self.b; }).b; } #pkgs result gets evaluated again
     fix = pkgs*: let result = pkgs* result; in (pkgs* result): { a = 3; b = 4; c = ({ a = 3; b = 4; c = (pkgs* result).a+(pkgs* result).b; }).a + ({ a = 3; b = 4; c = (pkgs* result).a+(pkgs* result).b; }).b; } #we expand self to pkgs result
     fix = pkgs*: let result = pkgs* result; in (pkgs* result): { a = 3; b = 4; c = (a = 3;).a + (b = 4;).b; } #we don't really need to expand pkgs again because c is not evaluated, we only need a and b.
     fix = pkgs*: let result = pkgs* result; in (pkgs* result): { a = 3; b = 4; c = 3 + 4; } 
     fix = pkgs*: let result = pkgs* result; in (pkgs* result): { a = 3; b = 4; c = 7; } # done!
   Ok, can this lead to an infinite recursion? sure, if we have something like
      f = self: {a=self.b; b=self.c; c=self.d; d = self.a; };
   But the nixpkgs carefully avoids this situation.

   How does this work with nixpkgs? nixpkgs packages that depend on another
   nixpkgs package refer to their dependencies as "self." (e.g.  grahpviz =
   callPackage ./graphviz.nix {xorg=self.xorg}). nixpkgs is a function that
   accepts a parameter "self". That parameter is nixpkgs itself (i.e. a
   function). When the first nixpkgs is evaluated, "(pkgs(pkgs(... " it will
   make use of the nixpkgs that has been passed to it in the arguments when it
   encounters a package that refers to a package in nixpkgs (self.xorg, that
   self is the argument to nixpkgs that is a possibly modified nixpkgs).  When
   we want to override nixpkgs, we pass a modified nixpkgs as argument, we do
   something like nixpkgs(nixpkgs // override). This way, the first nixpkgs
   will pick the overriden version when it refers to "self".  Note however that
   the result of nixpkgs(nixpkgs // override) contains the old version of
   "override", it has just rebuilt everything with the new override, but kept
   the old override. To pick the new override we do "nixpkgs(nixpkgs //
   override) // override"

   Here is another example

    let
      f = self: {a=self.b; b=self.c; c=self.d; d = 1; };
      override = {d = 2;};
      res = let result = f result; in result;
      ove = let result = f (result//override); in result;
      ovefull = let result = ((f (result // override)) // override); in result;
     in {res=res; ove=ove; ovefull=ovefull;}
   where 
     res     = { a = 1; b = 1; c = 1; d = 1; }
     ove     = { a = 2; b = 2; c = 2; d = 1; }
     ovefull = { a = 2; b = 2; c = 2; d = 2; }




NIX LANGUAGE
 - nix repl : open Nix interpreter
 - in nix everything is inmutable
 - 2/3 : this is a path, not a division
 - 2/ 3 : division
 - 2-3 : this is an identifier, not a substraction
 - ${var} : variable reference. $var {$var} not allowed
 - "foo" or ''foo'' : string. 'foo' is not allowed
 - ''I plot a "string" without escaping''
 - "I'm escaping \${foo}" : escape in ""
 - ''I'm escaping ''${foo}'' : escape in ''
 -  [ 2 "foo" true (2+3) ] : create list (separate by space, not comma). modify list creates a new list.
 - s = { foo = "bar"; a-b = "baz"; "123" = "num"; } : attribute sets (like dict)
   s.a-b : access element
   s."123" : access element
   strings can be used to access not valid keys
 - rec { a = 3; b = a+4; } : recursive set (use a key in the definition, note the "rec" at the beginning"
 - if a > b then "yes" else "no" : if's always must have else
 - let a = 4; b = a + 5; in b : "let" defines and "in" evaluates
 - with expressions:
    longName = { a = 3; b = 4; }
    longName.a + longName.b
    with longName; a + b : same as above
 - lazy evaluation:
    let a = builtins.div 4 0; b = 6; in b
   this works because a is not used, and expressions are only evaluated when used (in)
 - functions
    - x: x*2 -> annonymous function
    - double x: x*2 -> named function
    - double 2 -> calling function
    - multi argument functions
       - mul = a: (b: a*b) -> mult 3 returns function (b:3*b), then (mul 2) 3 works as expected
       - it can be written as "mul = a: b: a*b" and "mul 2 3"
    - mul = s: s.a*s.b -> called with mul {a=3; b=4;}
    - mul = { a, b }: a*b -> called as above
    - functions with argument sets mut have the same numbe of parameters when called
    - mul = { a, b ? 2 }: a*b -> default value. Called with "mul { a = 3; }"
    - mul = { a, b, ... }: a*b -> variadic. Can be called as "mul { a = 3; b = 4; c = 2; }"
    - To acess variadic arguments, we must give a name to the set with "name@":
       mul = s@{ a, b, ... }: a*b*s.c
    - a = import ./test.nix -> import a file and store it's contest in a (test.nix contians "3")
    - import ./test.nix {a=3} -> call a function defined (test.nix contains a function definition)
    - let x = 5; in import ./test.nix -> the scope is not inherited (test.nix contains "x") and it fails!
 - debug
    - builtins.trace is a built-in function that takes two arguments. The first is the message to display, the second is the value to return. It's usually used for debugging purposes. 
 - derivations
    - create a derivation and build
       d = derivation { name = "myname"; builder = "mybuilder"; system = "mysystem"; } -> create derivation. this creates the .drv file in the store, but does not build
       :b d -> actually build
    - { type = "derivation"; } -> this apparently general set, is interepted by the nix engine as a "derivation"
    - builtins.toString <derivation> -> return outPath
    - :l <nixpkgs> -> load nixkpkgs repo/channel derivations
    - "${coreutils}" -> returns outPath string (drv path in filesystem)
    - "${coreutils}/bin/true" -> returns outPath string (drv path in filesystem)
 - builtins
    - :? -> show all nix repl commands
    - builtins. <press tab> : to show all builtins
    - builtins.currentSystem : returns system name, such as "x86_64-linux"
    - builtins.isAttrs <symbol> : returns true if symbol is a set
    - builtins.attrNames : returns names of set
    - builtins.toString <symbol> : convert to string

TROUBLESHOOTING
 - if you have locale issues:
     export LOCALE_ARCHIVE=/usr/lib/locale/locale-archive


