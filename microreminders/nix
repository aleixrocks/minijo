PRINCIPLES
 - There isn't anything like apt which solves a SAT problem in order to satisfy
   dependencies with lower and upper bounds on versions. There's no need for
   this because all the dependencies are static: if a derivation X depends on a
   derivation Y, then it always depends on it. A version of X which depended on
   Z would be a different derivation. 
 - nix derivatives : packages (including version and specific deps)
 - nix channel : repository of nix packages. a channel can be just a directory
   with the git clone of the nixpkgs repo. Essentially it must have a
   default.nix file that evalutes to an attribute set ( {ping=...; bash=...; ...;}
   containing derivatives.
 - nix expressions : descriptions of a package/derivative
 - The Nix language is used to write expressions that produce derivations. The
   nix-build tool is used to build derivations from an expression.
 - The .nix files are like .c files. The .drv files are intermediate files like
   .o files. The .drv describes how to build a derivation, it's the bare
   minimum information. The output of a build is the "output" path.
 - Derivations are also stored in the nix store. But they only contain the
   instructions on how to build a program. Derivations can be created with the
   nix "derivation" function. 
 - The hash of the out path of a package is based solely on the input
   derivations in the current version of Nix, not on the contents of the build
   product (no sha on the resulting binary). It's possible however to have
   content-addressable derivations for e.g. tarballs.
 - The environment variables passed to the builder are just those you see in
   the .drv plus some other Nix related configuration (number of cores, temp
   dir, ...). The builder will not inherit any variable from your running
   shell, otherwise builds would suffer from non-determinism.
 - An attribute set (ej. {a=3; b="patata";}  with type="derivation" is nix's
   magic way to let it now that the set is a derivation. Another set special
   attribute is "outPath". If it exist, the builtins.toString or
   "${derviationVariable} will essentially return the contents of outPath.
 - The idea is that all sources should reside in the Nix store, since all
   inputs to a derivation should reside in the Nix store.
 - During build, every attribute in the derivation is passed as an environment
   variable to the builder. See
   https://nixos.org/manual/nix/stable/expressions/derivations.html for more
   details.
 - if an attribute of "derivation" is a path (/...) it is copied into the nix
   store first. hence, we can keep track of all sources in the store.
 - each derivation can have multiple outputs. Each output has a name (out is
   the generic one) and this corresponds to a path in the nix store. These
   names are exported as env variables to the builder who needs to do what's
   necessary to copy into each output path what's expected (e.g. headers, libs,
   dev libs, doc, etc).
 - derivations have dependencies to other derivations. When inspecting one with
   nix show-derivation <name>.drv, you will see the .drv dependencies and the
   specific outputs of the .drv this derivation depends on.
 - nix components:
    - /nix/store : installation path of all packages
    - /nix/var/nix/db : sqlite database that keep track of packages
    - ~/.nix-profile : this is a nix package that works as a kind
      of a root directory. But nothing is installed here, is only a
      simlink. We can install packages in this "profile". For each
      package installed, a new generation is created (another
      profile) which is installed in the store and this simlink is
      updated to point to the new one. Profiles are here
      /nix/var/nix/profiles/per-user/aleix/ but they are only
      simlinks to the store.
    - ~/.nix-defexpr/channels : this contains the repos with the "expressions"
      of packages.
    - /etc/nix/nix.conf : nix global configurations. See
      https://nixos.org/manual/nix/stable/command-ref/conf-file.html for
      options
    - NIX_PATH : env var containing the path to repositories of nix
      expressions. They contain a default.nix which nix commands evaluate to
      find derivatives. These repositories are paths with names assigned, e.g.
      : nixpkgs=/nix/var/nix/profiles/per-user/aleix/channels/nixpkgs . When
      referring to this repos inside nix expressions (.nix files) you can do so
      as <nixpkgs>. Be aware that nix-env does not uses NIX_PATH but
      ~/.nix-defexpr as source for its repositories. If you want to use a repo
      from NIX_PATH in nix-env, use nix-env -f '<myRepo>' -A <attrName> . You
      can also use -I <path> in some nix tools to add a path instead of
      NIX_PATH. For more info, see
      https://nixos.org/guides/nix-pills/nix-search-paths.html
    - nix-env : command to manage the environment (profiles and
      packages installed there)
    - nix-instantiate <name>.nix : command that takes a .nix file and build a
      .drv file.
    - nix-store: command to manage the store itself and build. nix-store -r
      takes a .drv file and build the package itself.
    - nix-build: command that takes a .nix file, builds a .drv file and runs
      nix-store -r on the .drv to build the package. If no file is provided, it
      will read a "default.nix" in the current directory. If this file contains
      an attribute set, you can specify which attribute you want it to read
      with -A, e.g. nix-build -A graphviz. Instead of default.nix, you can also
      specify a NIX_PATH such as nix-build '<nixpkgs' -A bash.
    - nix-channel: command to manage channels (repos)
    - nix-repl: command to try the NIX language interactively
    - source ~/.nix-profile/etc/profile.d/nix.sh : load all nix commands and
      envs (used when nix is not installed using the system's packet manager)
    - nix-shell file.nix :  builds a derivation and opens an interactive bash
      with the build environment loaded, but no build is done. From here, it is
      possible to run the builder to build the package, but you might not have
      permissions to write into the store nor you will be cd into a nix
      temporal build dir.

BASIC
 - nix-env -i <pkg> : install package into the current user environment
 - nix-env --uninstall <pkdg> : remove package from the user environment
 - nix-env -u : upgrade all packages in the environment. Remember to run first
   nix-channel --update to update the local nixpkgs repo!
 - nix-env -u <pkg> : only upgrade <pkg>
 - nix search <pkg> : search for a package to install
 - nix-env -qa : show available pacakges for installation
 - nix-env -qas : show installed packages: I (installed in current user env) P
   (installed in the system) S (thre is a pre-compiled binary avaialble for
   download)
 - nix-env -qs --installed : show only packages in the current profile
 - nix-env -qa --description neovim : show version of package. Rememeber
   using -f <path> if specifiying a local nix repository.
 - nix-shell <name.nix> : enter a nix user environemnt defined in name.nix
 - nix-shell --pure <name.nix> : enter a nix user environemnt, only that is
   defined in name.nix is available.
 - nix log <path to store> : show build log


NIX SHELL
 - the new command is "nix shell". You can use it has "nix shell -f . gdb" to
   open a gdb reading default.nix from the current directory.
 - on "nix shell" you can set the prompt with
     export PS1="\[\033[1;32m\][nix shell:\w]\$\[\033[0m\] "
 - nix-shell opens a shell and provides the specified packages to build a
   derivation. It can also be used as a virtual shell where some packages have
   been made available into PATH.
     nix-shell --pure -p vim gdb curl
 - nix-shell attemps to read ./shell.nix and, if not found, default.nix from
   the current dir.
 - nix-shell -p <derivation1> <derivation2> ... : add packages to shell. These
   packages are read from <nixpkgs>, not from the current shell.nix or
   default.nix! If you need to add here custom packages, you can use the -I
   option, or redefine nixpkgs in NIX_PATH or use shell.nix. Example:
     - nix-shell -I nixpkgs=./default.nix -p mypkgs
     - NIX_PATH='nixpkgs=.' nix-shell -p mypkg
 - nix-shell -A <derivation> : open a shell with all the packages needed to
   build the derivation.
 - nix-shell --pure : clean up env and provide only nix packages instead of
   system ones.
 - shell.nix example:
     { pkgs ? import <nixpkgs> {} }:
     with pkgs;
     mkShell {
       name = "sc-shell";
     
       buildInputs = [
         vim
       ];
     
       shellHook = ''
         alias l="ls -l --color=auto -v"
         alias ll="ls -l --color=auto -v"
         alias lh="ls -hAl --color=auto -v"
         alias ls="ls --color=auto -v"
         alias ..="cd .."
     
         export LANG=C
         export SHELL=${bash}/bin/bash
       '';
     }

SEARCH FOR A PACKAGE
 - search using webiste: https://search.nixos.org/packages#openshift

GENERATIONS
 - nix-env --list-generations : show history of environemnts
 - nix-env --rollback : go back to previous environemnt state
 - nix-env -G <environment_name> : go the specified environment as lised by --list-generations
 - ~/.nix-profiles/ : current environment
 - ~/.nix-profiles/bin : current binaries (these are a simlink to the nix store)

STORE
 - /nix/store : nix store where all binaries really are
 - nix-store -q --references `which command` : shows dependencies of package.
   Be sure that the path is either an absolute path or a symlink to a command
   in the nix store.
 - nix-store -q --referrers `which command` : shows which packages depend on this package.
 - nix-store -qR <path> : list all dependencies including absolutely everything
   needed to run this. This is named "closure" in nix terminology.
 - nix-store -q -tree <path> : show dependencies as a tree

CHANNELS
 - nix-channel --list : list channels (repositories)
 - nix-channel --update : update list of expressions/(descriptions of packages)

DERIVATIONS
 - nix-store -r <path.drv> : build/realise derivation
 - nix show-derivation <path.drv> : pretty print derivation
    - nix show-derivation -f <path to .nix>
    - nix show-derivation clang.cc | jq -r '.[].env.buildInputs' :  only show field env.buildInputs
    - nix show-derivation numactl clang.cc | jq -r '.[].env | {name, buildInputs}' : show both name and buildInputs

DIFF
 -  nix-diff --environment <store_path> <store_path> : show differences between
    derivations, this is not an standard tool

FLAKES
 - doc:
    - nix flake --help 
 - nix flake metadata github:edolstra/dwarffs : fetch flake metadata
 - nix flake show github:edolstra/dwarffs : see flake outputs
 - nix build github:edolstra/dwarffs : build the <system> output by default
   (<system> is something as "x86_64-linux")
 - nix build github:edolstra/dwarffs#checks.aarch64-linux.build : build a particular output
 - Build the "c-nosv_attach-bug" packages from branch "asan-fix" of non-github repo
   and force fetching the git submodules of such repo.
    $ nix build git+https://gitlab.bsc.es/arocanon/nixdev?submodules=1&ref=asan-fix#c-nosv-attach-bug
 - these two are equivalent, the first uses the "flake registry" to figure out the url
    $ nix shell nixpkgs#cowsay --command cowsay Hi!
    $ nix shell github:NixOS/nixpkgs#cowsay --command cowsay Hi!
 - change the flake registry:
    $ nix registry add nixpkgs ~/my-nixpkgs
    $ nix registry add nixpkgs github:NixOS/nixpkgs/5272327b81ed355bbed5659b8d303cf2979b6953
 - working with flakes:
    - git init
    - nix flake init : create a basic flake.nix file.
    - git add flake.nix : Note that any file that is not tracked by Git is
      invisible during Nix evaluation, in order to ensure hermetic evaluation.
      Thus, you need to make flake.nix visible to Git.
    - nix build : build the package
    - nix shell --command hello : run it!
    - nix develop : get an interactive development environment
  - nix flake lock --update-input nixpkgs : update nixpkgs commit in flakes.lock
  - nix flake check : check something
  - nix flake show templates : show flake.nix templates
  - nix flake init -t templates#simpleContainer : create initial flake.nix from template
  - nix build /path/to/my-flake#nixosConfigurations.container.config.system.build.toplevel : 
    build nixos config. Note that system.build.toplevel is an internal NixOS
    option that evaluates to the “system” derivation that commands like
    nixos-rebuild, nixos-install and nixos-container build and activate. The
    symlink /run/current-system points to the output of this derivation.
  - nixos-version : returns the commit hash where the flake is
  - nix repl on flakes:
     cat > ./nixos-config.nix <<EOF
     (builtins.getFlake (toString ./.)).nixosConfigurations
     EOF
     nix repl ./nixos-config.nix
  - url-like syntax: this "github:NixOS/nixpkgs" is the same as:
     inputs.nixpkgs = {
       type = "github";
       owner = "NixOS";
       repo = "nixpkgs";
     };
  - path-like syntax: This points to a local git repo with a flake.nix.
    defaults to master branch, it ignores uncommited changes:
      git+file:///home/aleix/bsc/projects/bscpkgs
    branch test with commit ref only
      git+file:///home/aleix/bsc/projects/bscpkgs?ref=test
    branch test with commit rev
      git+file:///home/aleix/bsc/projects/bscpkgs?ref=test&rev=805b30d130b63807e2755eb4e776a8e61320cffd#
  - multiple inputs in a flake might have different versions of nixpkgs. To unificate them use "follow":
      inputs {
        bscpkgs.url = "git+https://pm.bsc.es/gitlab/rarias/bscpkgs.git";
        nixpkgs.follows = "bscpkgs/nixpkgs";
      }
      

GARBAGE COLLECTOR
 - /nix/var/nix/gcroots : contains simlinks to garbage collector roots
   (gcroots). These packages nor their dependencies will never be deleted.
   everythingelse will if the gargabe collector is run. all links under
   /nix/var/nix/profiles are also gcroots, so our env and generations are not
   deleted. the "results" link after a build is also a gc root (the softlink
   file itself, not the .drv it points to!)
 - nix-collect-garbage : command to run the garbage collector
 - nix-store -q --roots `which fortune` : points to the gcroot derivation that
   keeps the fortune package alive after runninc the garbage collector
 - nix-store --gc --print-roots : prints all gc roots
 - clean up all
    - steps: 
       nix-channel --update
       nix-env -u --always
       rm /nix/var/nix/gcroots/auto/*
       nix-collect-garbage -d
    - First, we download a new version of the nixpkgs channel, which holds the
      description of all the software. Then we upgrade our installed packages
      with nix-env -u. That will bring us into a fresh new generation with all
      updated software.
    - Then we remove all the indirect roots generated by nix-build: beware,
      this will result in dangling symlinks. You may be smarter and also remove
      the target of those symlinks.
    - Finally, the -d option of nix-collect-garbage is used to delete old
      generations of all profiles, then collect garbage. After this, you lose
      the ability to rollback to any previous generation. So make sure the new
      generation is working well before running the command.
    - more info at: https://nixos.org/guides/nix-pills/garbage-collector.html

UTILITIES
 - lib.lists.<function> : operations on lists at lib/lists.nix
 - lib.lists.remove 3 [ 1 2 3 ] : returns [ 1 2 ]
 - makeExtensible (lib/fixed-points.nix) : make a function to accept an overlay
    nix-repl> obj = makeExtensible (self: { })
    nix-repl> obj = obj.extend (self: super: { foo = "foo"; }) # the new obj is extensible too!
 - substituteInPlace <file> --replace "old" "new" : replace old by new in <file>
 - patchShebangs <script>.{sh,py} : replace the shebang interpreter. The
   file must be executable for this to be effective!
 - abort s : abort expression and print "s"
 - throw s : abort expression and print "s" but it won't abort if only
   attempting to print info of the derivation
 - lib.optional (a == 0) b : returns [ b ] if a == 0 is true
 - lib.optionalString (a == 0) "b" : returns "b" if a == 0 is true
 - a -> b : a implies b
 - assert (a == 0) : a normal assert, can be used just as "with"
 - assert lib.assertMsg (a == 0) "message" : assert with message 
 - nixpkgs.path: contains the path to the nixpkgs source code. It can be
   useful to redefine a derivation from the nix expression in an overlay, as
   done in the nixpkgs' top level. e.g.
     llvmPackages_11 = super.callPackage (super.path + /pkgs/development/compilers/llvm/11
 - <nixpkgs>/pkgs/stdenv/adapters.nix: contain functions that modify an stdenv
 - <derivation>.outPath : the real path to the installed derivation (where the
   "out" is in the system). Useful on nix repl to figure out where something is
   installed, like stdenv.cc.cc.outPath

DEBUG
 - cmake: 
    - set makeFlags=["VERBOSE=1"]; on the derivation
    - export makeFlags="VERBOSE=1"; on a nix develop shell
    - export makeFlags="VERBOSE=1 -j1"; to ease finding the failing command and error

GET THE SOURCE OF A PACKAGE
 - nix-shell -A hello : opens a shell with stdenv and build dependencies
   loaded.
 - eval ${unpackPhase:-unpackPhase} : get and unpack source code in the current
   directory. Now you can examine it!

GET URL AND SHA OF A GITHUB PACKAGE
 - you can get the github tar.gz of a commit as:
     https://github.com/PROJECT/REPO/archive/COMMITID.tar.gz
   e.g.
     https://github.com/nixos/nixpkgs/archive/481f9b246d200205d8bafab48f3bd1aeb62d775b.tar.gz
   or in gitlab
     https://pm.bsc.es/gitlab/ompss-kernel/linux/-/archive/bc11660676d3d68ce2459b9fb5d5e654e3f413be/linux-bc11660676d3d68ce2459b9fb5d5e654e3f413be.tar.gz
     https://pm.bsc.es/gitlab/ompss-kernel/linux/-/archive/bc11660676d3d68ce2459b9fb5d5e654e3f413be.tar.gz
   but make sure that the http page is public! If it needsa autentication, you won't be able to download it.
 - you can easily calculate the hash as:
     nix-prefetch-url --unpack  <url>
     nix-prefetch-git <url> <commit hash>
   or change the derivation for
     hash = lib.fakeHash;
   and recompute or
     hash = "";
 - builtins.fetchGit needs an url, a ref and a rev.
    - url: needs to be changed from github provided
       git@github.com:bsc-pm/llvm.git 
       ssh://git@github.com/bsc-pm/llvm.git
    - ref: if a branch can be specified direclty, such as "master" but if it is
      a tag, it needs to be like:
       "refs/tags/<tag>"
    - commit: just a commit

WHICH SHA IS MY CURRENT NIXPKGS ON?
 - use the sha after the dot stored in:
     cat .nix-defexpr/channels/nixpkgs/svn-revision 
 - note that this file is not in the original nixpkgs github repo!

WHERE IS DEFINED THE NIX SOURCE OF A FUNCTION?
 - type in nix repl:
     nix-repl> glibc.overrideAttrs
     «lambda @ /nix/store/86242z3mxd6lqxyrhdl6vv78rzww6k3z-nixpkgs/nixpkgs/lib/customisation.nix:85:73»

WHY IS NIX BUILD TRIGGERING A REBUILD? WHAT HAS CHANGED?
 - nix-diff <derivation or store path> <derivation or store path>

GET THE DERIVATION OF A STORE PATH
 - nix-store --query --deriver <store path>

PYTHON DOCUMENTATION
 - doc/languages-frameworks/python.section.md

SHELL WITH PYHTON PACKAGES
 - nix-shell -p python3 python310Packages.pandas

BUILDING A PYTHON PACKAGE
 - nix build -f . python310Packages.pyfakefs # package pyfakefs for python 3.10

OVERRIDE A PYTHON PACKAGE USING OVERLAYS
 - doc: https://nixos.org/manual/nixpkgs/stable/#how-to-override-a-python-package-using-overlays
 - careful when copying this code, be sure to remove trailing whitespaces
    python310 = super.python310.override {
      packageOverrides = python-self: python-super: {
        pyfakefs = python-super.pyfakefs.overrideAttrs(oldAttrs: {
          ''
            substituteInPlace pyfakefs/tests/fake_pathlib_test.py \
              --replace "test_owner_and_group_posix" "notest_owner_and_group_posix"
          '';
      };
    };


NIX PORTABLE
 - patch nix portable to create a full isolation:
      diff --git a/default.nix b/default.nix
      index b8f4def..6ef2a96 100644
      --- a/default.nix
      +++ b/default.nix
      @@ -241,7 +241,7 @@ let
             ### gather paths to bind for proot
             # we cannot bind / to / without running into a lot of trouble, therefore
             # we need to collect all top level directories and bind them inside an empty root
      -      pathsTopLevel="\$(find / -mindepth 1 -maxdepth 1 -not -name nix -not -name dev)"
      +      pathsTopLevel="\$(find / -mindepth 1 -maxdepth 1 -not -name nix -not -name dev -not -name opt -not -name apps -not -name usr -not -name lib -not -name lib64 -not -name bin)"
       
       
             toBind=""
      @@ -330,8 +330,8 @@ let
               --bind \$dir/emptyroot /\\
               --dev-bind /dev /dev\\
               --bind \$dir/ /nix\\
      +        --bind \$dir/busybox/bin/busybox /bin/sh\\
               \$binds"
      -        # --bind \$dir/busybox/bin/busybox /bin/sh\\
           else
             # proot
             collectBinds
  - build x86 static nix-portabl
      nix build #packages.x86_64-linux.nix-portable

RUNCOMMAND
 - runCommand is a mkDerivation wrapper. It generates a derivation, and it must
   create a $out output. For instance, we can use runCommand to create a src
   for a derivation

     src = runCommand "${pname}-src" {} ''
       mkdir -p "$out"
       cp -r ${monorepoSrc}/cmake "$out"
       cp -r ${monorepoSrc}/${pname} "$out"
     '';

Fixed-output Derivations (fdo)
 - An fdo is a special kind of derivation whose output hash only considers the
   derivation name and the src. It is useful for derivations such as fetchurl,
   in which you only care about the output itself (you don't care if the url of
   the targz has changed or the version of curl used to download it, you only
   care about the .tar.gz having matching an expected hash). Read more here:
     https://nixos.org/manual/nix/stable/language/advanced-attributes.html?highlight=outputHash#adv-attr-outputHash


INSTALLING NIX
 - you might need to set up NIX_SSL_CERT_PATH to your certificate file for both the client and the server.
 - to generate a certificate bundle, you can build one with nix on a machine with an already running nix installation
     nix-build -A cacert '<nixpkgs>'
   and transfer it to your new machine
 - you might need to setup proxy for the nix daemon in mira en /etc/systemd/system/nix-daemon.service.d/override.conf
    [Service]
    Environment=http_proxy=localhost:23080
    Environment=https_proxy=localhost:23080
    Environment=ftp_proxy=localhost:23080
    Environment=NIX_SSL_CERT_FILE=/home/Computational/arocanon/cert/cacert.pem
    LimitNOFILE=64000                                                                
    TasksMax=infinity 



UNDERSTANDING NIXPKGS REPOSITORY
 - The <nixpkgs> repository is a function that accepts some parameters and
   returns the set of all packages. Due to laziness, only the accessed
   derivations will be built.
 - the default.nix evalutes to a function instead of an attribute set. If
   nix-build finds a function instead of an attribute set, it will call the
   function once and evaluate the resulting derivation. This works if the
   function has default parameters of if parameters are passed with --arg
   option. (actually, note that nix-build expectes a derivation, not an
   attribute set, that's why we specify allways the derivation inside the set
   using -A).
 - One of the parameters is system. we can use it for cross compilation. e.g.
   nix-build -A psmisc --argstr system i686-linux (but I'm not much confident
   on this)
 - nixpkgs default.nix reads the nixpkgs config file at
   ~/.config/nixpkgs/config.nix . This con be accesses inside nix repl as "pkgs
   = import <nixpkgs> {}; pkgs.config". The location can also be specified at
   import time as import <nixpkgs> {config = import ./config.nix}
 - If we want to modify a nixpkgs package and also want all packages that
   depend on the modified one to recompile, we need to override it. To do so,
   we can add the following in the config file:
    {
      packageOverrides = pkgs: {
        graphviz = pkgs.graphviz.override { xorg = null; };
      };
    }
   this uses fixed point as explained below. However, it is more powerful to
   use overlays. packageOverrides acts as an overlay with only the super
   argument. It is therefore appropriate for basic use, but overlays are more
   powerful and easier to distribute.

 - What if we want to override a package internal attributes rather than the
   arguments that it accepts before calling mkDerivation? we can use the helper
   <package>.overrideAttrs. The oldAttrs argument refers to the unmodified
   attributes:

     glibc = super.glibc.overrideAttrs (oldAttrs: rec {
        version = "2.27";
        name = "glibc-${version}";
        src = builtins.fetchurl {
            url    = "https://ftp.gnu.org/gnu/glibc/glibc-${version}.tar.xz";
            sha256 = "0wpwq7gsm7sd6ysidv0z575ckqdg13cr2njyfgrbgh4f65adwwji";
        };
     });

 - Overlays are used to add or modify a nixpkgs package and all related
   packages in cascade (fix point below). Here is all info on overlays:
   https://nixos.org/manual/nixpkgs/stable/#chap-overlays
     import <nixpkgs> { overlays = [ overlay1 overlay2 ]; }.
     
     overlay1 = self: super:
     {
       boost = super.boost.override {
         python = self.python3;
       };
       rr = super.callPackage ./pkgs/rr {
         stdenv = self.stdenv_32bit;
       };
     }

   The first argument (self) corresponds to the final package set. You should use
   this set for the dependencies of all packages specified in your overlay. For
   example, all the dependencies of rr in the example above come from self, as
   well as the overridden dependencies used in the boost override.

   The second argument (super) corresponds to the result of the evaluation of
   the previous stages of Nixpkgs. It does not contain any of the packages added
   by the current overlay, nor any of the following overlays. This set should be
   used either to refer to packages you wish to override, or to access functions
   defined in Nixpkgs. For example, the original recipe of boost in the above
   example, comes from super, as well as the callPackage function.

 - stdenv is a "package" used to build other packages in nixpkgs. stdenv
   contains only a "setup" bash script that defines functions to automatically
   build with autotools. You can see it with cd $(nix-build '<nixpkgs>' -A
   stdenv). This is sourced by the nixpkgs builder and calls genericBuild
   function in setup to build everything. The stdenv derivative also contains
   the mkDerivative function, which is used by to create derivatives of all
   nixpkgs packages. Note that mkDerivative is only in the stdenv derivative
   attribute set, but not in the "binary" (nix store). stdenv derivative is
   defined in pkgs/stdenv/generic/default.nix . To build the derivation it uses
   the "derivation" builtint directly instead of mkDerivation, of course. It
   provides its out builder.sh to build itself. It just copies setup.sh and a
   few more lines in the output directory. Note how "mkDerivation" is defined
   as an attribute inside the stdenv derivative attribute set, and note that
   the stdenv itself is passed to mkDerivation. 

   To build a package with nixpackge, use mkDerivation

   Low level stdenv: https://nixos.org/guides/nix-pills/fundamentals-of-stdenv.html
   All stdenv info can be found in https://nixos.org/manual/nixpkgs/stable/#chap-stdenv

 - mkDerivation essentially calls the "derivation" builtin to create a nix
   derivation attribute set, but first it provides a standard build environment
   through stdenv including gcc, tar, gzip, ... and the stdenv setup build
   script to actually build something made with autotools. To see the
   mkDerivation builder.sh, run "nix-build '<nixpkgs>' -A stdenv; cat
   result/setup" here you can see the code for all variables, hooks and phases.
   The mkDerivation doc can also be found under
   https://nixos.org/manual/nixpkgs/stable/#chap-stdenv

     stdenv.mkDerivation rec {
       pname = "libfoo"; # The final drv name is "pname-version".
       version = "1.2.3";
       src = fetchurl {
         url = "http://example.org/libfoo-source-${version}.tar.bz2";
         sha256 = "0x2g1jqygyr5wiwg4ma1nd7w4ydpy82z9gkcv8vh2v8dn3y58v5m";
       };
     }
     
    - buildInputs = [ which hello ]; : direct dependencies of the package
    - propagatedBuildInputs = [ which hello ]; : like buildInputs, but these
      packages are written into $out/nix-support/propagated-build-inputs for
      the current package. Then, if another package imports this package, it
      will source all what's in $out/nix-support/propagated-build-inputs . This
      allows for a package "A" using propagateBuildInputs to make a set of
      packages "Aset" available to a package "B" having "A" as its buildInputs
      to accesses "Aset" without importing them explicitly in its buildInputs.
      see for more info: https://nixos.org/guides/nix-pills/basic-dependencies-and-hooks.html
    - buildPhase = substitute the generic builder build phase for the contents
      of this variable. Example:
        buildPhase = ''
          gcc foo.c -o foo
        '';
    - configureFlags = a list of strings containing options to pass to configure.
    - makeFlags = a list of variables to pass to make. you can check them in
      your nix-shell! echo $makeFlags.
    - installPhase = subsitute the generic builder install phase for the
      contents of this variable. Example:
        installPhase = ''
          mkdir -p $out/bin
          cp foo $out/bin
        '';
    - you can inspect any of the functions defined by nix in a bash shell with:
       - type installPhase
    - we can skip phases by adding dontInstall=true; dontBuild=true;
      dontConfigure=true; etc. Look at stdenv setup for the available options, it's
      easy to spot.
    - To skip the configure phase, use doCheck = false and doInstallCheck =
      false instead.
    - NIX_CFLAGS_COMPILE : this env var adds options to the underlying
      compiler. This works because stdenv provies a cc wrapper that parses this
      env var among doing other things.
    - setuphook: If a package has a setupHook=./setup-hook.sh attribute, all
      packages that include this package will run the setup-hook.sh script.
      This allows to run arbitrary code in any package. This works by storing
      the hook under the package pkg/nix-support/setup-hook.  this will be
      sourced by any stdenv-based build including that as a dependency. 
      more info: https://nixos.org/manual/nixpkgs/stable/#ssec-setup-hooks
      The following example, forces all packages inlcluding 'middle-man' to be
      compiled with frame pointers.

        --- middle-man.nix ---
        {stdenv}:
        stdenv.mkDerivation {
          name = "middle-man";
          src = ./middle-man.sh;
          setupHook = ./setup-hook.sh;

          dontUnpack=true;
          dontPatch=true;
          dontConfigure=true;
          dontBuild=true;
          #dontFixup=true; #this loads setupHook!
                                                                                                                                            
          installPhase = ''
            mkdir -p $out/bin
            cp $src $out/bin
          '';
        }

        --- ./setup-hook.sh ----
        echo "@@@@@@@@@@@@@@@@@I'm the setup hook!@@@@@@@@@@@@@@@@@"                                                                        
        export NIX_CFLAGS_COMPILE="-fno-omit-frame-pointer "$NIX_CFLAGS_COMPILE 
        
        --- hello.nix ---
        {stdenv, middle-man}
        stdenv.mkDerivation {
           name = hello;
           src = ...
           buildInputs = [middle-man];
        }     
        
    - envHooks: similar to setuphook. see fore more
      https://nixos.org/guides/nix-pills/basic-dependencies-and-hooks.html

 - How to recompile the whole system with some compilation option. Create a new
   stdenv with a modified mkDerivation that appends the extra compilation
   option to NIX_CFLAGS_COMPILE. To create a new stdenv, we use an "adapter"
   (<nixpkgs>/pkgs/stdenv/adapters.nix), a helper function that modifies stdenv
   for us. To add cflags, we have withCFlags function:

     let
       nixpkgs = import <nixpkgs> {overlays=[overlay1];};
       overlay1 = self: super: # self is the new, super is the old
       {
         stdenv = super.withCFlags [ "-fno-omit-frame-pointer" ] super.stdenv;                                                       
       };
     in nixpkgs

   Storing this as default.nix and running in the same directory nix-build -A
   hello, will trigger building all hello dependencies (including glibc) with
   the new options.
 
 - Override the glibc. This causes a whole system build. Be aware that the
   glibc is built with a boostrap stdenv which has an older compiler than the
   current "gcc" in nixpkgs.

     glibc = super.glibc.overrideAttrs (oldAttrs: rec {
        version = "2.27";
        name = "glibc-${version}";
        src = builtins.fetchurl {
            url    = "https://ftp.gnu.org/gnu/glibc/glibc-${version}.tar.xz";
            sha256 = "0wpwq7gsm7sd6ysidv0z575ckqdg13cr2njyfgrbgh4f65adwwji";
        };
     });

 - update boostrap tools. The boostrapTools or boostrapFiles are a set of
   pre-built binaries uses to boostrap a system. They are downloaded from the
   nixpkgs servers and used to build stdenv in 5 steps. A good introduction can
   be found here:
     http://trofi.github.io/posts/240-nixpkgs-bootstrap-intro.html
   We can change the boostrap tools, but we first need to generate a new one. To do so, run:
     nix build -f ./pkgs/stdenv/linux/make-bootstrap-tools.nix bootstrapFiles
   this will take the current nixpkgs gcc and pack it into boostrap.  then,
   modify nixpkgs and add the path to the generated boostrap tools. I have
   found no way to override this, so I needed to hardcore it. 
     pkgs/stdenv/linux/bootstrap-files/x86_64.nix
   to use your modified nixpkgs instead of the default one, modify the
   "nixpkgs" path inside NIX_PATH.

 - How nixpkgs is boostraped. First check this:
     http://trofi.github.io/posts/240-nixpkgs-bootstrap-intro.html
   It first loads default.nix in nixpkgs. This leads to 
     ./default.nix
     ./pkgs/top-level/impure.nix
     ./pkgs/top-level/default.nix
   The last one, build a list "stages" containg functions that describe how to
   build the 5 stdenv stages. The "boot" is a function that builds the stdenv
   functions by piping them one after the other (I think)
     129   pkgs = boot stages;
   The stdenv stages are here:
     ./pkgs/stdenv/default.nix # this selects the stdenv for linux
     ./pkgs/stdenv/linux/default.nix # this acutally contains the 5 stages
   To build the stages, it uses a prebuilt set of binaries named boostrapTools.
   This is fetched from nix server instead of being built. However, nixpkgs
   also contains the .nix describing how to build it. This is found under:
     ./pkgs/stdenv/linux/make-bootstrap-tools.nix




FUNDAMENTAL NIXPKGS

 - callPackage: nix trick to transparently find the arguments of a function.
   Given a function, it gets its argument names and intersects them with
   derivations found in allPkgs (nixpkgs).
     callPackage = path: overrides:
     let f = if builtins.isPath path then import path else path;
     in f ((builtins.intersectAttrs (builtins.functionArgs f) allPkgs) // overrides);
   see for more details: https://nixos.org/guides/nix-pills/callpackage-design-pattern.html

 - makeOverridable: nix trick to embedd a function into a derivation. This
   function allows to recreate the derivation with a new set of arguments. the
   new set overrides the original one, but keeps all fields that have not been
   explicitly set by the override method. Here is how it works:
     makeOverridable = f: args:
       let origRes = f args;
       in origRes // {myOverride = newArgs: makeOverridable f (args // newArgs); };
   see for more details: https://nixos.org/guides/nix-pills/override-design-pattern.html
 - Fixed point with lazy evaluation: we use this technique to modify a package
   in nixpkgs and all its dependencies.
     fix = f: let result = f result; in result
     pkgs = self: { a = 3; b = 4; c = self.a+self.b; } #assume that this is nixpkgs, where a, b and c are derivations, but c depends on a and b.
     fix pkgs
   Now we expand this step by step: 
     fix = pkgs*: let result = pkgs* result; in result
     fix = pkgs*: let result = pkgs* result; in pkgs* result
     fix = pkgs*: let result = pkgs* result; in pkgs* (pkgs* result)  # instead of evaluating the innermost pkgs, we evaluate first the outermost pkgs!
     fix = pkgs*: let result = pkgs* result; in self: { a = 3; b = 4; c = self.a+self.b; } #self is the paramter to the outermost pkgs call.
     fix = pkgs*: let result = pkgs* result; in (pkgs* result): { a = 3; b = 4; c = (pkgs* result).a + (pkgs* result).b; }
     fix = pkgs*: let result = pkgs* result; in (pkgs* result): { a = 3; b = 4; c = ({ a = 3; b = 4; c = self.a+self.b; }).a + ({ a = 3; b = 4; c = self.a+self.b; }).b; } #pkgs result gets evaluated again
     fix = pkgs*: let result = pkgs* result; in (pkgs* result): { a = 3; b = 4; c = ({ a = 3; b = 4; c = (pkgs* result).a+(pkgs* result).b; }).a + ({ a = 3; b = 4; c = (pkgs* result).a+(pkgs* result).b; }).b; } #we expand self to pkgs result
     fix = pkgs*: let result = pkgs* result; in (pkgs* result): { a = 3; b = 4; c = (a = 3;).a + (b = 4;).b; } #we don't really need to expand pkgs again because c is not evaluated, we only need a and b.
     fix = pkgs*: let result = pkgs* result; in (pkgs* result): { a = 3; b = 4; c = 3 + 4; } 
     fix = pkgs*: let result = pkgs* result; in (pkgs* result): { a = 3; b = 4; c = 7; } # done!
   Ok, can this lead to an infinite recursion? sure, if we have something like
      f = self: {a=self.b; b=self.c; c=self.d; d = self.a; };
   But the nixpkgs carefully avoids this situation.

   How does this work with nixpkgs? nixpkgs packages that depend on another
   nixpkgs package refer to their dependencies as "self." (e.g.  grahpviz =
   callPackage ./graphviz.nix {xorg=self.xorg}). nixpkgs is a function that
   accepts a parameter "self". That parameter is nixpkgs itself (i.e. a
   function). When the first nixpkgs is evaluated, "(pkgs(pkgs(... " it will
   make use of the nixpkgs that has been passed to it in the arguments when it
   encounters a package that refers to a package in nixpkgs (self.xorg, that
   self is the argument to nixpkgs that is a possibly modified nixpkgs).  When
   we want to override nixpkgs, we pass a modified nixpkgs as argument, we do
   something like nixpkgs(nixpkgs // override). This way, the first nixpkgs
   will pick the overriden version when it refers to "self".  Note however that
   the result of nixpkgs(nixpkgs // override) contains the old version of
   "override", it has just rebuilt everything with the new override, but kept
   the old override. To pick the new override we do "nixpkgs(nixpkgs //
   override) // override"

   Here is another example

    let
      f = self: {a=self.b; b=self.c; c=self.d; d = 1; };
      override = {d = 2;};
      res = let result = f result; in result;
      ove = let result = f (result//override); in result;
      ovefull = let result = ((f (result // override)) // override); in result;
     in {res=res; ove=ove; ovefull=ovefull;}
   where 
     res     = { a = 1; b = 1; c = 1; d = 1; }
     ove     = { a = 2; b = 2; c = 2; d = 1; }
     ovefull = { a = 2; b = 2; c = 2; d = 2; }




NIX LANGUAGE
 - nix repl : open Nix interpreter
 - in nix everything is inmutable
 - 2/3 : this is a path, not a division
 - 2/ 3 : division
 - 2-3 : this is an identifier, not a substraction
 - ${var} : variable reference. $var {$var} not allowed
 - "foo" or ''foo'' : string. 'foo' is not allowed
 - ''I plot a "string" without escaping''
 - "I'm escaping \${foo}" : escape in ""
 - ''I'm escaping ''${foo}'' : escape in ''
 -  [ 2 "foo" true (2+3) ] : create list (separate by space, not comma). modify list creates a new list.
 - s = { foo = "bar"; a-b = "baz"; "123" = "num"; } : attribute sets (like dict)
   s.a-b : access element
   s."123" : access element
   strings can be used to access not valid keys
 - rec { a = 3; b = a+4; } : recursive set (use a key in the definition, note the "rec" at the beginning"
 - if a > b then "yes" else "no" : if's always must have else
 - let a = 4; b = a + 5; in b : "let" defines and "in" evaluates
 - with expressions:
    longName = { a = 3; b = 4; }
    longName.a + longName.b
    with longName; a + b : same as above
 - lazy evaluation:
    let a = builtins.div 4 0; b = 6; in b
   this works because a is not used, and expressions are only evaluated when used (in)
 - functions
    - x: x*2 -> annonymous function
    - double x: x*2 -> named function
    - double 2 -> calling function
    - multi argument functions
       - mul = a: (b: a*b) -> mult 3 returns function (b:3*b), then (mul 2) 3 works as expected
       - it can be written as "mul = a: b: a*b" and "mul 2 3"
    - mul = s: s.a*s.b -> called with mul {a=3; b=4;}
    - mul = { a, b }: a*b -> called as above
    - functions with argument sets mut have the same numbe of parameters when called
    - mul = { a, b ? 2 }: a*b -> default value. Called with "mul { a = 3; }"
    - mul = { a, b, ... }: a*b -> variadic. Can be called as "mul { a = 3; b = 4; c = 2; }"
    - To acess variadic arguments, we must give a name to the set with "name@":
       mul = s@{ a, b, ... }: a*b*s.c
    - a = import ./test.nix -> import a file and store it's contest in a (test.nix contians "3")
    - import ./test.nix {a=3} -> call a function defined (test.nix contains a function definition)
    - let x = 5; in import ./test.nix -> the scope is not inherited (test.nix contains "x") and it fails!
 - debug
    - builtins.trace is a built-in function that takes two arguments. The first is the message to display, the second is the value to return. It's usually used for debugging purposes. 
 - derivations
    - create a derivation and build
       d = derivation { name = "myname"; builder = "mybuilder"; system = "mysystem"; } -> create derivation. this creates the .drv file in the store, but does not build
       :b d -> actually build
    - { type = "derivation"; } -> this apparently general set, is interepted by the nix engine as a "derivation"
    - builtins.toString <derivation> -> return outPath
    - :l <nixpkgs> -> load nixkpkgs repo/channel derivations
    - "${coreutils}" -> returns outPath string (drv path in filesystem)
    - "${coreutils}/bin/true" -> returns outPath string (drv path in filesystem)
 - builtins
    - :? -> show all nix repl commands
    - builtins. <press tab> : to show all builtins
    - builtins.currentSystem : returns system name, such as "x86_64-linux"
    - builtins.isAttrs <symbol> : returns true if symbol is a set
    - builtins.attrNames : returns names of set
    - builtins.toString <symbol> : convert to string

NIX FETCHERS
 - urls:
    - github to nix:
        change this: git@bscpm03.bsc.es:llvm-ompss/llvm-mono.git
        to this:     ssh://git@bscpm03.bsc.es/llvm-ompss/llvm-mono.git
    - local repo: It seems that they must be an absolute path.
        fetchgit {
         url = "file:///home/aleix/nixdev/pkgs/blis/src";
         rev = "refs/tags/0.9.0";
         hash = "sha256-1aHIdt5wCDrT1hBPnaUVThwjwDkJQ0G0+tao2iFXYpM=";
        }
        builtins.fetchGit {
         url = pkgs/blis/src;
         rev = "refs/tags/0.9.0";
         hash = "sha256-1aHIdt5wCDrT1hBPnaUVThwjwDkJQ0G0+tao2iFXYpM=";
        }
 - builtins.fetchGit. This is a builtins, the doc is under the nix reference
   manual. This fetches the git repo at evaluation time. You don't need to
   specify a commit or a branch here, it will fetch the default one.  This
   means that everytime you evaluate this derivation, it will check for a new
   version.
   This only needs a "url", but it optionally you can
   specify a "rev" (commit), a ref (branch or tag name). Note that there is no
   hash here, because this is not a fod.
   Instead, you can directly specify a local git directory:
     builtins.fetchGit ./work-dir
     builtins.fetchGit {
       url = "/home/aleix/repo";
       ref = "patata-branch";
     }
     builtins.fetchGit {
       url = repo; # note, this is a path, not a string!
       ref = "patata-branch";
     }
   AFAIK, the "url = repo" doesn't cause "repo" to be copied to the nix store
   first (prior to evaluating builtins.fetchGit) because builtins.fetchGit is
   not a derivation, and path is not a string interpolation. Of course, the
   result of evaluating builtins.fetchGit returns a nix store path with the
   repo checked out.
   Also, I think that it is not possible to set a relative path in "url", not
   even a "path" data type as in fetchGit (it fails at build time). Setting a
   string interpolated path does not work either. 
 - fetchgit: This is a package, the doc is under nixpkgs manual. This creates a
   "fod" derivation. And the git repo is fetched at build time. Once it has
   been fetched once, it will not be fetched again as long as there is a store
   path whose name and "hash" combined match the store path (even if the url or
   the "rev" changes!). 
   This needs and "url" and a "rev" (commit, tag or branch) and a hash. The
   hash can be empty at first, and nix will fail and output the expected one.

PATHS
 - This path
     this-is-a-path = pkgs/blis/src;
   evaluates to: /home/Computational/arocanon/bsc/projects/nixdev/pkgs/blis/src
   this is not copied to the nix store
 - This path
     this-is-a-path-interpolated = "${pkgs/blis/src}";
   evaluates to: "/nix/store/gp6n56k7fkbg7p0304612q2hz631qdyp-src". The dollar
   (string interpolation) causes the directory to be copied into the Nix store
   and result in the string. More about string interpolation here: https://nixos.org/manual/nix/stable/language/string-interpolation.html
 - When a path is present inside a derivation (such as pkgs/blis/src), it is
   always copied into the nix store first, prior to creating the derivation.
   https://nixos.org/manual/nix/stable/language/derivations.html
  


TROUBLESHOOTING
 - if you have locale issues:
     export LOCALE_ARCHIVE=/usr/lib/locale/locale-archive


